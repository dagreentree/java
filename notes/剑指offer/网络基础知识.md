[TOC]

### 网络基础知识

#### 1、七层结构

市面上存在四层、五层、七层 协议,国际标准化组织ISO提出的OSI七层协议模型是业界概念型框架
1层：物理层：解决两台物理机之间的通讯需求（相互发送比特流），定义了物理设备的标准，如网线的类型，光纤的接口类型，网卡就是工作在这一层。
2层：数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路，定义了如何格式化数据以进行传输；如何控制对物理介质的访问；通常还提供错误检测和纠正，以确保数据传输的可靠性，本层将比特数据组合成了帧，其中交换机工作在本层。
3层：网络层：控制子网的运行，如逻辑编址、分组传输、路由选择。其主要功能是将网络地址翻译成对应的物理地址并决定如何将数据由发送方路由到接收方，路由器工作在本层。
4层：传输层：接收上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端（TCP/UDP）。 5层：会话层：不同机器上的用户之间建立及管理会话。
6层：表示层：信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩。
7层：应用层：HTTP协议

#### 2、TCP/IP

| OSI七层模型 | TCP/IP概念层模型 | 功能                  | TCP/IP协议                           |
| ------- | ----------- | ------------------- | ---------------------------------- |
| 应用层     | 应用层         | 文件传输、电子邮件、文件服务、虚拟终端 | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
| 表示层     |             | 数据格式化、代码转换、数据加密     | 没有协议                               |
| 会话层     |             | 解除或建立与别的接点的联系       | 没有协议                               |
| 传输层     | 传输层         | 提供端对端的接口            | TCP,UDP                            |
| 网络层     | 网络层         | 为数据包选择路由            | IP,ICMP,RIP,OSPF,BGP,ICMP          |
| 数据链路层   | 链路层         | 传输有地址的帧以及错误检测功能     | SLIP,CSLIP,PPP.ARP,RARP,MTU        |
| 物理层     |             | 以二进制数据形式在物理媒体上传输数据  | ISO2110,IEEE802,IEEE802.2          |

#### 3、TCP的三次握手

传输控制协议TCP简介：  

- 面向连接的、可靠的、基于字节流的传输层通讯协议
- 将应用层的数据流分割成报文段并发送给目标结点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

TCP报文头：   

![TCP报文结构](C:\Users\zhjch\Desktop\新建文件夹\pic\TCP报文结构.png)

- 16位源端口号和16位目的端口号。
- 32位序号：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
- 32位确认号：用来响应TCP报文段，给收到的TCP报文段的序号加1，三握时还要携带自己的序号。
- 4位头部长度：标识该TCP头部有多少个4字节，共表示最长15*4=60字节。同IP头部。
- 6位保留。6位标志。URG（紧急指针是否有效）ACK（表示确认号是否有效）PSH（提示接收端应用程序应该立即从TCP接收缓冲区读走数据）RST（表示要求对方重新建立连接）SYN（表示请求建立一个连接）FIN（表示通知对方本端要关闭连接）
- 16位窗口大小：TCP流量控制的一个手段，用来告诉对端TCP缓冲区还能容纳多少字节。
- 16位校验和：由发送端填充，接收端对报文段执行CRC算法以检验TCP报文段在传输中是否损坏。
- 16位紧急指针：一个正的偏移量，它和序号段的值相加表示最后一个紧急数据的下一字节的序号。



在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

![TCP三次握手](C:\Users\zhjch\Desktop\新建文件夹\pic\TCP三次握手.png)

第一次握手：建立连接时，客户端发送SYN包（syn=i）到服务器，并进入SYN_SEND状态，等待服务器确认；  

第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK 包，此时服务器进入SYN_RECV状态；  

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1]，此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手。

为什么需要三次握手才能建立起连接：为了初始化Sequence Number的初始值。  

首次握手的隐患---SYN超时
问题起因分析：

>Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认
>
>Server不断重试直至超时，Linux默认等待63秒才断开连接

针对SYN Flood的防护措施

>SYN队列满后，通过tcp_syncookies参数回发SYN Cookie
>若为正常连接则Client会回发SYN Cookie，直接建立连接

建立连接后，Client出现故障怎么办保活机制

>向对方发送保活探测报文，如果未收到响应则继续发送
>尝试次数达到保活探测数仍未收到响应则中断连接

#### 4、TCP的四次挥手

TCP采用四次挥手来释放连接
第一次挥手：Client 发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；

第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server 进入CLOSE_WAIT状态；

第三次挥手：Server发送一个FIN，用来关闭 Server到Client的数据传送，Server 进入LAST_ACK状态；

第四次挥手：Client收到FIN后，Client 进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server 进入CLOSED状态，完成四次挥手。



为什么会有TIME_WAIT状态
原因

>确保有足够的时间让对方收到ACK包
>避免新旧连接混淆

为什么需要四次握手才能断开连接：因为全双工，发送方和接收方都需要FIN报文和ACK报文。

服务器出现大量CLOSE_WAIT状态的原因：对方关闭socket连接，我方忙于读或写，没有及时关闭连接

>检查代码，特别是释放资源的代码
>检查配置，特别是处理请求的线程配置

#### 5、TCP和UDP的区别

![UDP报文结构](C:\Users\zhjch\Desktop\新建文件夹\pic\UDP报文结构.png)

UDP的特点

>面向非连接
>
>不维护连接状态，支持同时向多个客户端传输相同的消息
>数据包报头只有8个字节，额外开销较小
>吞吐量只受限于数据生成速率、传输速率以及机器性能
>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
>面向报文，不对应用程序提交的报文信息进行拆分或者合并

TCP和UDP的区别
结论

>面向连接Vs无连接
>可靠性
>有序性
>速度
>
>量级

#### 6、TCP的滑动窗口

RTT和RTO

>RTT：发送一个数据包到收到对应的ACK，所花费的时间
>RTO：重传时间间隔

TCP使用滑动窗口做流量控制与乱序重排

>保证TCP的可靠性
>保证TCP的流控特性

#### 7、HTTP简介

超文本传输协议HTTP主要特点

>支持客户/服务器模式
>简单快速
>灵活
>无连接
>无状态 

**HTTP请求结构**

![HTTP请求结构](C:\Users\zhjch\Desktop\新建文件夹\pic\HTTP请求结构.png)

**HTTP响应结构**

![HTTP响应结构](C:\Users\zhjch\Desktop\新建文件夹\pic\HTTP响应结构.png)

**请求/响应的步骤**

>客户端连接到Web服务器
>发送HTTP请求
>服务器接受请求并返回HTTP响应
>释放连接TCP连接
>客户端浏览器解析HTML内容

**在浏览器地址栏键入URL，按下回车之后经历的流程答案**

>DNS解析>TCP连接
>发送HTTP请求
>服务器处理请求并返回HTTP报文
>浏览器解析渲染页面
>连接结束

**HTTP状态码五种可能的取值**

>1xx：指示信息--表示请求已接收，继续处理
>2xx：成功--表示请求已被成功接收、理解、接受
>3xx：重定向--要完成请求必须进行更进一步的操作>4xx：客户端错误--请求有语法错误或请求无法实现
>5xx：服务器端错误--服务器未能实现合法的请求

200OK：正常返回信息
400Bad Request：客户端请求有语法错误，不能被服务器所理解
401 Unauthorized：请求未经授权，这个状态代码必须和wwW-Authenticate报头域一起使用

403 Forbidden：服务器收到请求，但是拒绝提供服务

404Not Found：请求资源不存在，eg，输入了错误的URL
500 Internal Server Error：服务器发生不可预期的错误

503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常

**GET请求和POST请求的区别：**
从三个层面来解答

>Http报文层面：GET将请求信息放在URL，POST放在报文体中
>数据库层面：CET符合幂等性和安全性，POST不符合
>其他层面：GET可以被缓存、被存储，而POST不行

**Cookie和Session的区别Cookie简介**

>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
>客户端再次请求的时候，会把Cookie回发
>服务器接收到后，会解析Cookie生成与客户端相对应的内容